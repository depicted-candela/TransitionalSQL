<head>
    <link rel="stylesheet" href="../styles/lecture.css">
    <link rel="stylesheet" href="../styles/exercises.css">
</head>
<body>

<div class="container">

<h1>Speed Unleashed: Oracle Indexing and Query Insights</h1>

<p>Welcome to the practical arena where theory meets execution. This set of exercises is meticulously designed to solidify your understanding of Oracle's performance and optimization fundamentals. You will move from conceptual knowledge to hands-on application, learning how to analyze, index, and improve query performance within the Oracle Database 23ai ecosystem.</p>

<div class="postgresql-bridge">
    <p>As a professional with a strong PostgreSQL background, you'll find some concepts like B-Tree indexes and execution plans familiar. These exercises are tailored to bridge that knowledge, focusing on Oracle-specific syntax, powerful features like Bitmap and Function-Based indexes, and the nuances of interpreting Oracle's detailed <code>EXPLAIN PLAN</code> output.</p>
</div>

<h2>Learning Objectives</h2>
<p>Upon completing this set of exercises, you will be able to:</p>
<ul>
    <li>Choose and create the appropriate Oracle index (B-Tree, Bitmap, Function-Based, Composite) for a given query scenario.</li>
    <li>Confidently generate, read, and interpret Oracle execution plans using <code>EXPLAIN PLAN</code> and <code>DBMS_XPLAN</code>.</li>
    <li>Identify common performance bottlenecks such as full table scans and non-SARGable predicates.</li>
    <li>Understand the performance trade-offs of indexing, particularly the overhead on DML operations.</li>
    <li>Apply your knowledge to solve a complex, multi-faceted query problem that integrates hierarchical queries, analytic functions, and optimal indexing strategies.</li>
</ul>

<h2>Prerequisites & Setup</h2>
<p>Before beginning, ensure you are comfortable with the concepts from the preceding chunks of this course, especially:</p>
<ul>
    <li>Key Differences & Core Syntax</li>
    <li>Hierarchical Queries</li>
    <li>Analytic (Window) Functions</li>
</ul>

<h3>Dataset: The <code>speedUnleash</code> Schema</h3>
<p>These exercises require a specific dataset. Please connect to your Oracle Database as a user with administrative privileges (like <code>SYSTEM</code>) to create the dedicated user, then connect as that new user to create the necessary tables and data.</p>
<div class="oracle-specific">
    <h5>Setup Tip</h5>
    <p>You can run the entire script below in a tool like SQL Developer or SQL*Plus. The script first creates the <code>speedUnleash</code> user and then, after you connect as that user, builds the required tables and populates them with data designed to test various performance scenarios.</p>
</div>

<pre><code>-- Step 1: Connect as an admin user (e.g., SYSTEM) to create the new schema/user
CREATE USER speedUnleash IDENTIFIED BY YourSecurePassword1;
GRANT CONNECT, RESOURCE, UNLIMITED TABLESPACE TO speedUnleash;
ALTER USER speedUnleash QUOTA UNLIMITED ON USERS;
GRANT CREATE VIEW, CREATE PROCEDURE, CREATE TRIGGER TO speedUnleash;

-- Step 2: Now, disconnect and reconnect as the 'speedUnleash' user to run the rest of the script.

-- Table Creation
CREATE TABLE customers (
    customerId NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customerName VARCHAR2(100) NOT NULL,
    region VARCHAR2(10) NOT NULL,
    registrationDate DATE NOT NULL,
    managerId NUMBER,
    CONSTRAINT fkManager FOREIGN KEY (managerId) REFERENCES customers(customerId)
);

CREATE TABLE products (
    productId NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    productName VARCHAR2(100) NOT NULL,
    category VARCHAR2(50) NOT NULL
);

CREATE TABLE customerOrders (
    orderId NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customerId NUMBER NOT NULL,
    productId NUMBER NOT NULL,
    orderDate DATE NOT NULL,
    orderStatus VARCHAR2(15), -- Low cardinality, some NULLs
    quantity NUMBER(10) NOT NULL,
    unitPrice NUMBER(10, 2) NOT NULL,
    CONSTRAINT fkCustomer FOREIGN KEY (customerId) REFERENCES customers(customerId),
    CONSTRAINT fkProduct FOREIGN KEY (productId) REFERENCES products(productId)
);

-- Data Population
-- Populate customers with a hierarchy
INSERT INTO customers (customerId, customerName, region, registrationDate, managerId) VALUES (1, 'Global Corp', 'AMER', DATE '2022-01-10', NULL);
INSERT INTO customers (customerId, customerName, region, registrationDate, managerId) VALUES (2, 'National Inc', 'AMER', DATE '2022-02-15', 1);
INSERT INTO customers (customerId, customerName, region, registrationDate, managerId) VALUES (3, 'Statewide LLC', 'AMER', DATE '2022-03-20', 2);
INSERT INTO customers (customerId, customerName, region, registrationDate, managerId) VALUES (4, 'Local Services', 'AMER', DATE '2022-04-25', 3);
INSERT INTO customers (customerId, customerName, region, registrationDate, managerId) VALUES (5, 'Euro Group', 'EMEA', DATE '2022-01-15', NULL);
INSERT INTO customers (customerId, customerName, region, registrationDate, managerId) VALUES (6, 'DE Holdings', 'EMEA', DATE '2022-02-20', 5);
INSERT INTO customers (customerId, customerName, region, registrationDate, managerId) VALUES (7, 'UK Ventures', 'EMEA', DATE '2022-03-25', 5);
INSERT INTO customers (customerId, customerName, region, registrationDate, managerId) VALUES (8, 'APAC Partners', 'APAC', DATE '2022-01-20', NULL);
INSERT INTO customers (customerId, customerName, region, registrationDate, managerId) VALUES (9, 'Sunrise Trading', 'APAC', DATE '2022-05-10', 8);
INSERT INTO customers (customerId, customerName, region, registrationDate, managerId) VALUES (10, 'southern cross', 'APAC', DATE '2022-06-15', 8);

-- Populate products
INSERT INTO products (productName, category) VALUES ('Laptop Pro', 'Electronics');
INSERT INTO products (productName, category) VALUES ('Wireless Mouse', 'Electronics');
INSERT INTO products (productName, category) VALUES ('Office Chair', 'Furniture');
INSERT INTO products (productName, category) VALUES ('Standing Desk', 'Furniture');

-- Populate customerOrders with a significant number of rows
BEGIN
    FOR i IN 1..2500 LOOP
        INSERT INTO customerOrders (customerId, productId, orderDate, orderStatus, quantity, unitPrice)
        VALUES (TRUNC(DBMS_RANDOM.VALUE(1, 11)), TRUNC(DBMS_RANDOM.VALUE(1, 5)),
                TO_DATE('2023-01-01', 'YYYY-MM-DD') + DBMS_RANDOM.VALUE(0, 364),
                CASE TRUNC(DBMS_RANDOM.VALUE(1, 6))
                    WHEN 1 THEN 'PENDING'
                    WHEN 2 THEN 'SHIPPED'
                    WHEN 3 THEN 'DELIVERED'
                    WHEN 4 THEN 'CANCELLED'
                    ELSE NULL
                END,
                TRUNC(DBMS_RANDOM.VALUE(1, 10)), TRUNC(DBMS_RANDOM.VALUE(50, 2000), 2));
    END LOOP;
    -- Add specific orders for targeted queries
    INSERT INTO customerOrders (customerId, productId, orderDate, orderStatus, quantity, unitPrice) VALUES (9, 1, SYSDATE - 10, 'SHIPPED', 2, 1500);
    INSERT INTO customerOrders (customerId, productId, orderDate, orderStatus, quantity, unitPrice) VALUES (10, 1, SYSDATE - 5, 'DELIVERED', 1, 1450);
END;
/
COMMIT;
</code></pre>

<h2>Your Mission: The Exercises</h2>
<p>The exercises are divided into four thematic sections. This structure will guide you from understanding the core value of each concept to identifying its limitations and, finally, to synthesizing everything to solve a complex, real-world problem.</p>
<ul>
    <li><strong>(i) Meanings, Values, Relations, and Advantages:</strong> Focus on the "what" and "why" of Oracle's performance features.</li>
    <li><strong>(ii) Disadvantages and Pitfalls:</strong> Explore the trade-offs and common mistakes associated with these features.</li>
    <li><strong>(iii) Contrasting with Inefficient Common Solutions:</strong> Learn to identify and correct suboptimal approaches.</li>
    <li><strong>(iv) Hardcore Combined Problem:</strong> Integrate all your knowledge up to this point in a single, challenging scenario.</li>
</ul>

<hr>

<h2>(i) Meanings, Values, Relations, and Advantages</h2>
<p>These exercises focus on the "what" and "why" of Oracle's indexing and plan analysis tools, contrasting with PostgreSQL where relevant.</p>

<h3>Exercise 1: <span class="problem-label">The Foundation - From Full Scan to B-Tree Index</span></h3>
<p><strong>Problem:</strong></p>
<p>You are tasked with retrieving all orders for a specific <code>productId</code>. First, analyze the performance of this query without any indexes. Then, create a standard B-Tree index on the <code>productId</code> column in the <code>customerOrders</code> table and analyze the plan again.</p>
<ol>
    <li>Write a query to select all columns from <code>customerOrders</code> where <code>productId</code> is 2.</li>
    <li>Generate the execution plan for this query.</li>
    <li>Create a standard B-Tree index named <code>idxOrderProduct</code> on the <code>productId</code> column.</li>
    <li>Generate the execution plan for the same query again.</li>
    <li><strong>Analysis:</strong> Describe the key differences between the two plans. What operations changed, and why is the second plan more efficient for retrieving a small subset of data?</li>
</ol>

<h3>Exercise 2: <span class="problem-label">Low Cardinality Power - The Bitmap Index</span></h3>
<p><strong>Problem:</strong></p>
<p>Queries filtering on <code>orderStatus</code> are common for reporting. Since <code>orderStatus</code> has very few distinct values (low cardinality), a Bitmap index is a potential optimization.</p>
<ol>
    <li>Write a query to count orders for each status where the status is either 'SHIPPED' or 'PENDING'.</li>
    <li>Create a Bitmap index named <code>idxOrderStatusBitmap</code> on the <code>orderStatus</code> column.</li>
    <li>Generate the execution plan for the query.</li>
    <li><strong>Analysis:</strong> Identify the <code>BITMAP</code> operations in the plan and explain why a Bitmap index is advantageous for this type of query and data.</li>
</ol>

<h3>Exercise 3: <span class="problem-label">Indexing an Expression - The Function-Based Index</span></h3>
<p><strong>Problem:</strong></p>
<p>Your application often needs to search for customers by name, but the search must be case-insensitive. The <code>customerName</code> column, however, contains mixed-case data. A normal index on <code>customerName</code> would be useless for a query with <code>WHERE UPPER(customerName) = '...'</code>.</p>
<ol>
    <li>Create a function-based index that stores the uppercase version of <code>customerName</code>.</li>
    <li>Write a query to find the <code>customerId</code> for 'sunrise trading' (note the lowercase).</li>
    <li>Generate and analyze the execution plan to confirm the new index is used.</li>
</ol>

<h3>Exercise 4: <span class="problem-label">The Composite Index and the Leading Column Rule</span></h3>
<p><strong>Problem:</strong></p>
<p>A common query pattern is to look up all orders for a specific customer that occurred after a certain date.</p>
<ol>
    <li>Create a composite (multi-column) index on <code>(customerId, orderDate)</code> on the <code>customerOrders</code> table.</li>
    <li>Generate the execution plan for a query that filters by <strong>both</strong> <code>customerId</code> and <code>orderDate</code>.</li>
    <li>Generate the execution plan for a query that filters <strong>only</strong> by <code>customerId</code>.</li>
    <li>Generate the execution plan for a query that filters <strong>only</strong> by <code>orderDate</code>.</li>
    <li><strong>Analysis:</strong> Explain why the index was used in plans 2 and 3, but likely not in plan 4.</li>
</ol>

<hr>

<h2>(ii) Disadvantages and Pitfalls</h2>
<p>These exercises focus on when indexes can hurt performance or behave unexpectedly.</p>

<h3>Exercise 1: <span class="problem-label">The DML Overhead Pitfall</span></h3>
<p><strong>Problem:</strong></p>
<p>You have a table that undergoes heavy bulk updates. Demonstrate the conceptual cost of having too many indexes.</p>
<ol>
    <li>Create three additional (and somewhat redundant) indexes on the <code>customerOrders</code> table: one on <code>quantity</code>, one on <code>unitPrice</code>, and a composite on <code>(orderStatus, orderDate)</code>.</li>
    <li>Write an <code>UPDATE</code> statement that modifies the <code>quantity</code> and <code>unitPrice</code> for all 'PENDING' orders.</li>
    <li><strong>Analysis:</strong> You don't need to run the <code>UPDATE</code>. Instead, explain step-by-step what Oracle must do behind the scenes when this single <code>UPDATE</code> statement is executed, considering all the indexes now on the table (<code>PK_orderId</code>, <code>idxOrderProduct</code>, <code>idxOrderStatusBitmap</code>, <code>idxCustOrderDate</code>, and the three new ones).</li>
</ol>

<h3>Exercise 2: <span class="problem-label">The Non-SARGable Predicate Pitfall</span></h3>
<p><strong>Problem:</strong></p>
<p>A developer needs to find all orders placed in the year 2023. They write a query using <code>TO_CHAR(orderDate, 'YYYY') = '2023'</code>. An index exists on <code>orderDate</code>. Explain why the index will not be used.</p>
<ol>
    <li>Ensure an index exists on <code>orderDate</code> in the <code>customerOrders</code> table.</li>
    <li>Generate the execution plan for the developer's query: <code>SELECT COUNT(*) FROM customerOrders WHERE TO_CHAR(orderDate, 'YYYY') = '2023';</code>.</li>
    <li><strong>Analysis:</strong> Explain why the plan shows a <code>TABLE ACCESS FULL</code> and why this is inefficient.</li>
</ol>

<hr>

<h2>(iii) Contrasting with Inefficient Common Solutions</h2>
<p>This exercise highlights the performance difference between an idiomatic Oracle approach and a common but inefficient one.</p>

<h3>Exercise 1: <span class="problem-label">Date Range Scans vs. Function-based Filtering</span></h3>
<p><strong>Problem:</strong></p>
<p>Following up on the previous pitfall, you need to correct the developer's query to find all orders from 2023. The goal is to write a query that can effectively use the index on the <code>orderDate</code> column.</p>
<ol>
    <li>The inefficient query is <code>SELECT COUNT(*) FROM customerOrders WHERE TO_CHAR(orderDate, 'YYYY') = '2023';</code>.</li>
    <li>Write an efficient, SARGable query that finds all orders within the year 2023 using a date range.</li>
    <li>Generate and compare the execution plans for both queries.</li>
    <li><strong>Analysis:</strong> Explain why the second query is vastly superior in performance.</li>
</ol>

<hr>

<h2>(iv) Hardcore Combined Problem</h2>
<p>This problem integrates indexing, <code>EXPLAIN PLAN</code>, PL/SQL, analytic functions, and hierarchical queries.</p>

<h3>Exercise 1: <span class="problem-label">Executive Performance Dashboard Query</span></h3>
<p><strong>Problem:</strong></p>
<p>The executive team at 'APAC Partners' (<code>customerId</code> 8) wants a performance report. They need to identify the top 2 performing product categories for each of their direct sub-organizations ('Sunrise Trading' and 'southern cross') based on total sales revenue (<code>quantity * unitPrice</code>). The final report must show the sub-organization's name, its category, the total revenue for that category, and the rank of that category's performance within that sub-organization. The query must be case-insensitive when matching the top-level company name 'APAC Partners'.</p>
<p><strong>Task:</strong></p>
<ol>
    <li>
        <strong>Gather Statistics:</strong> Write a PL/SQL anonymous block to ensure the optimizer has the most up-to-date statistics for the <code>customers</code>, <code>products</code>, and <code>customerOrders</code> tables.
        <div class="oracle-specific">
            <p>For more information on the importance of statistics and the <code>DBMS_STATS</code> package, consult the <a href="../books/sql-tuning-guide/ch01_10-optimizer-statistics-concepts.pdf">Oracle® Database SQL Tuning Guide, Chapter 10, "Optimizer Statistics Concepts"</a>.</p>
        </div>
    </li>
    <li>
        <strong>Create Optimal Indexes:</strong> Based on the query requirements, determine the necessary B-Tree, Composite, and Function-Based indexes to make the query as efficient as possible. Write the <code>CREATE INDEX</code> statements.
        <div class="postgresql-bridge">
            <p>While you know B-Tree and Composite indexes from PostgreSQL, pay special attention to Oracle's Function-Based and Bitmap indexes, as they are key to solving specific performance challenges. Refer to the <a href="../books/database-concepts/ch05_indexes-and-index-organized-tables.pdf">Oracle® Database Concepts, Chapter 5, "Indexes and Index-Organized Tables"</a> for a refresher.</p>
        </div>
    </li>
    <li>
        <strong>Write the Query:</strong> Construct a single SQL statement to generate the required report. This will involve:
        <ul>
            <li>A hierarchical query (<code>CONNECT BY</code>) to find the direct sub-organizations of 'APAC Partners'.</li>
            <li>Joins between all three tables.</li>
            <li>A <code>GROUP BY</code> to aggregate revenue.</li>
            <li>An analytic function (<code>DENSE_RANK()</code>) to rank the categories within each company.</li>
        </ul>
    </li>
    <li>
        <strong>Analyze and Justify:</strong> Generate the <code>EXPLAIN PLAN</code> for your final query and add comments to your solution explaining why you chose each index and how each key part of the execution plan (e.g., joins, scans) reflects your indexing strategy.
        <div class="oracle-specific">
            <p>To understand the output, refer to the <a href="../books/sql-tuning-guide/ch01_6-explaining-and-displaying-execution-plans.pdf">Oracle® Database SQL Tuning Guide, Chapter 6, "Explaining and Displaying Execution Plans"</a>.</p>
        </div>
    </li>
</ol>

<h2>Tips for Success & Learning</h2>
<ul>
    <li><strong>Experiment:</strong> Don't just run the solution. Try creating different indexes or no indexes at all and compare the execution plans. Understanding *why* a plan changes is the goal.</li>
    <li><strong>Read the Plan Carefully:</strong> Pay close attention to the `Operation` column (`TABLE ACCESS FULL` vs. `INDEX RANGE SCAN`), the `Rows` (estimated cardinality), and the `Cost`.</li>
    <li><strong>Consult the Docs:</strong> When you see an operation in an execution plan you don't recognize, use the linked Oracle documentation to learn more about it.</li>
    <li><strong>Think in Sets:</strong> Always try to solve problems with a single, powerful SQL statement before resorting to procedural loops.</li>
</ul>

<h2>Conclusion & Next Steps</h2>
<p>Mastering indexing and query plan analysis is a cornerstone of effective Oracle database development. By completing these exercises, you have built a solid foundation for diagnosing and solving performance issues, a skill that is invaluable in any consulting or development role.</p>
<div class="rhyme">
    <p>With indexes sharp and plans so clear,<br>No slow query should you fear.<br>Next up, a deeper, finer art,<br>To pull performance worlds apart.</p>
</div>
<p>You are now ready to move on to the next topic in your journey: <strong>Performance Symphony: Tuning Oracle with Hints and Stats</strong>, where you will learn how to guide the optimizer and manage the statistics it relies on.</p>

</div>
</body>